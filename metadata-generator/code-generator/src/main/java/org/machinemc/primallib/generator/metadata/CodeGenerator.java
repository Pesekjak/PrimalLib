package org.machinemc.primallib.generator.metadata;

import com.google.common.base.Preconditions;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.squareup.javapoet.*;
import lombok.extern.java.Log;
import org.jetbrains.annotations.ApiStatus;
import org.machinemc.primallib.version.ProtocolVersion;

import javax.annotation.processing.Generated;
import javax.lang.model.element.Modifier;
import java.io.*;
import java.util.*;
import java.util.logging.Level;

/**
 * Generator of auto-generated metadata API code.
 */
@Log
public class CodeGenerator {

    // yarn names <-> MV entity type data
    private final Map<String, MVEntityTypeData> entityTypeData = new HashMap<>();

    private final File targetDirectory = new File("../../api/src/autogenerated/java");

    // Application entry point
    public static void main(String[] args) {
        try {
            new CodeGenerator().run();
        } catch (Exception exception) {
            log.log(Level.SEVERE, "Failed to generate the code" , exception);
        }
    }

    /**
     * Runs the code generator and creates new java files in the auto-generated source directory
     * of the api module.
     */
    public void run() throws Exception {
        if (!targetDirectory.exists() && !targetDirectory.mkdirs())
            throw new IOException("Failed to create the target directory");

        if (!targetDirectory.isDirectory())
            throw new IOException("Missing target directory");

        List<ProtocolVersion> versions = new ArrayList<>(List.of(ProtocolVersion.values()));
        versions.remove(ProtocolVersion.UNKNOWN);
        for (ProtocolVersion version : versions)
            collect(version);
        for (MVEntityTypeData data : entityTypeData.values())
            generate(data);
    }

    /**
     * Collects information for a single protocol version and saves it.
     *
     * @param version protocol version
     */
    private void collect(ProtocolVersion version) throws IOException {
        System.out.println("Generating data for " + version + " version...");
        JsonObject dataJson;
        try (InputStream is = CodeGenerator.class.getResourceAsStream("/data/metadata-data-" + version + ".json")) {
            Preconditions.checkNotNull(is, "Missing generated data in the resources folder for " + version);
            dataJson = JsonParser.parseReader(new InputStreamReader(is)).getAsJsonObject();
        }
        for (String key : dataJson.keySet()) {
            if (key.startsWith("_")) continue;
            MVEntityTypeData data = entityTypeData.computeIfAbsent(key, MVEntityTypeData::new);
            JsonObject entityJson = dataJson.getAsJsonObject(key);

            if (entityJson.has("inherits"))
                data.addParent(entityJson.get("inherits").getAsString());

            JsonArray fieldsJson = entityJson.get("fields").getAsJsonArray();

            for (JsonElement fieldElement : fieldsJson.asList()) {
                JsonObject fieldJson = fieldElement.getAsJsonObject();
                MVEntityTypeData.Field field = data.getField(fieldJson.get("name").getAsString());
                field.insertVersionData(version, fieldJson.get("index").getAsInt(), fieldJson.get("serializer").getAsString());
            }
        }
        System.out.println("Generated data for " + version + " version");
    }

    /**
     * Generates file for given entity type data.
     *
     * @param entityTypeData entity type data
     */
    private void generate(MVEntityTypeData entityTypeData) throws Exception {
        File javaFile = new File(targetDirectory, entityTypeData.getRelocated() + ".java");

        if (!javaFile.getParentFile().exists() && !javaFile.getParentFile().mkdirs())
            throw new IOException();

        if (!javaFile.getParentFile().isDirectory())
            throw new IOException();

        if (javaFile.exists() && !javaFile.delete()) throw new IOException();
        if (!javaFile.createNewFile()) throw new IOException();

        BufferedWriter writer = new BufferedWriter(new FileWriter(javaFile));
        String code = generateCode(entityTypeData);
        writer.write(code);
        writer.close();
    }

    /**
     * Writes code for given entity type data to the given writer.
     *
     * @param entityTypeData entity type data
     */
    private String generateCode(MVEntityTypeData entityTypeData) throws Exception {

        String relocated = entityTypeData.getRelocated();
        String simpleName = relocated.substring(relocated.lastIndexOf('/') + 1);
        String packageName = relocated.substring(0, relocated.lastIndexOf('/')).replace('/', '.');

        TypeSpec.Builder dataType = TypeSpec.interfaceBuilder(simpleName)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc(
                        "Applicable metadata fields for all entities inheriting {@link $T} type.",
                        getClassName(relocated)
                )
                .addSuperinterfaces(entityTypeData.getSortedParents().stream().map(CodeGenerator::getClassName).toList())
                .addAnnotation(AnnotationSpec.builder(Generated.class)
                        .addMember("value", "$S", CodeGenerator.class.getName())
                        .build()
                );

        TypeSpec.Builder initializerType = TypeSpec.classBuilder("Initializer")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);

        List<CodeBlock> initializers = new ArrayList<>();

        List<MVEntityTypeData.Field> fields = entityTypeData.getSortedFields();
        for (MVEntityTypeData.Field field : fields) {
            FieldCodeGenerator generator = new FieldCodeGenerator(field);

            dataType.addField(generator.createFieldSpec(
                    CodeBlock.of("Initializer.$L", field.getName()),
                    true,
                    Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL
                    ));

            initializerType.addField(generator.createFieldSpec(null, false, Modifier.STATIC, Modifier.FINAL));
            initializers.add(generator.createStaticBlock());
        }

        CodeBlock.Builder staticBlock = CodeBlock.builder();
        initializers.forEach(staticBlock::add);
        initializerType.addStaticBlock(staticBlock.build());

        initializerType.addJavadoc("Initializer for entity data fields that supports multiple version implementations.");
        initializerType.addAnnotation(ApiStatus.Internal.class);

        if (!fields.isEmpty())
            dataType.addType(initializerType.build());

        JavaFile javaFile = JavaFile.builder(packageName, dataType.build()).indent("    ").build();

        return javaFile.toString();
    }

    /**
     * Returns class name from internal class path.
     *
     * @param path internal class path
     * @return class name
     */
    private static ClassName getClassName(String path) {
        String simpleName = path.substring(path.lastIndexOf('/') + 1);
        String packageName = path.substring(0, path.lastIndexOf('/')).replace('/', '.');
        return ClassName.get(packageName, simpleName);
    }

}
